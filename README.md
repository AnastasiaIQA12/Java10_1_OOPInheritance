# Домашнее задание к занятию «Наследование и расширяемость систем. Проблемы наследования»
## Задача №1 - "Менеджер Товаров"
Необходимо реализовать менеджер товаров, который умеет:
1. Добавлять товары в репозиторий
1. Искать товары

Что нужно сделать:
1. Разработать базовый класс `Product`, содержащий `id`, название, стоимость
1. Разработать два унаследованных от `Product` класса: `Book` (с полями название* и автор) и `Smartphone` (с полями название* и производитель)
1. Разработать репозиторий, позволяющий сохранять `Product`'ы, получать все сохранённые `Product`'ы и удалять по `id`. Для этого репозиторий будет хранить у себя поле с типом `Product[]` (массив товаров).
1. Разработать менеджера, который умеет добавлять `Product`'ы в репозиторий и осуществлять поиск по ним. Для этого нужно создать класс, конструктор которого будет принимать параметром репозиторий, а также с методом `publiс void add(Product product)` и методом поиска (см. ниже).

#### Как осуществлять поиск
У менеджера должен быть метод `searchBy(String text)`, который возвращает массив найденных товаров 

```java
public class ProductManager {
  // добавьте необходимые поля, конструкторы и методы

  public Product[] searchBy(String text) {
    // ваш код
  }

  public boolean matches(Product product, String search) {
    if (product instanceof Book) { // если в параметре product лежит объект класса Book
      Book book = (Book) product; // положем его в переменную типа Book чтобы пользоваться методами класса Book
      if (book.getAuthor().contains(search)) { // проверим есть ли поисковое слово в данных об авторе
        return true;
      }
      if (book.getTitle().contains(search)) {
        return true;
      }
      return false;
    }
    ...
    return false;
  }
}
```

Менеджер при переборе всех продуктов, хранящихся в массиве (или в репозитории)*, должен для каждого продукта вызывать определённый в классе менеджера метод `matches`, который проверяет, соответствует ли продукт поисковому запросу.

Примечание*: если вы сделали репозиторий, то пусть менеджер забирает из репозитория все товары и сам уже по ним ищет.

При проверке на соответствие запросу книги проверяем по полям названия и автора, для смартфона по полям названия и производителя.

Требования к проекту:
1. Создать ветку (не делать ДЗ в `master`!)
1. Подключить плагин Surefire так, чтобы сборка падала в случае отсутсвия тестов
1. Подключить плагин JaCoCo в режиме генерации отчётов (обрушать сборку по покрытию не нужно)
1. Реализовать нужные классы и методы
1. Написать автотесты на метод поиска (только на метод поиска в менеджере), добившись 100% покрытия по branch'ам* 
1. Подключить CI на базе Github Actions и выложить всё на Github

**Итого**: должен быть репозиторий на GitHub, в котором расположен ваш Java-код в ветке (в `master` должен быть только `pom.xml`).

## Задача №2 - "Менеджер Товаров" (Rich Model)*

### Легенда
Достаточно часто объекты, моделирующие предметную область, называют моделями. Достаточно часто модели делают "глупыми", т.е. не содержащими никакой логики. Но есть и другой подход, который позволяет делать "умные" или "богатые" модели (Rich Model), которые могут уже содержать определённую логику.

Что нужно сделать:
1. Создайть новую ветку на базе ветки, в которой решена первая задача
1. Реализовать в классе `Product` метод `public boolean matches(String search)`, который определяет, подходит ли продукт поисковому запросу исходя из названия
1. Переопределить этот метод в дочерних классах, чтобы они сначала вызывали родительский метод и только если родительский метод вернул `false`, тогда проводили доп.проверки (`Book` - по автору, `Smartphone` - по производителю).
1. Уберать из менеджера все `instanceof` и метод `matches`, т.к. теперь есть "умные" модели и благодаря переопределению методов этот код больше не нужен
1. Написать unit-тесты на методы умных моделей 
1. Удостовериться, что ранее написанные тесты на менеджера (из решения задачи 1) проходят
 
**Итого**: должен быть репозиторий на GitHub, в котором расположен ваш Java-код в двух ветках (в `master` должен быть только `pom.xml`).

